<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>UFO í”¼í•˜ê¸° ê²Œì„</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: linear-gradient(to bottom, #000428, #004e92);
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-family: "Courier New", monospace;
        color: white;
      }

      #gameContainer {
        position: relative;
        border: 3px solid #fff;
        border-radius: 10px;
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
      }

      #gameCanvas {
        display: block;
        background: linear-gradient(to bottom, #001122, #003366);
      }

      #ui {
        position: absolute;
        top: 10px;
        right: 10px;
        font-size: 20px;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      }

      #instructions {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        font-size: 18px;
        line-height: 1.6;
        background: rgba(0, 0, 0, 0.7);
        padding: 20px;
        border-radius: 10px;
        border: 2px solid #fff;
      }

      #gameOver {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        font-size: 24px;
        background: rgba(255, 0, 0, 0.8);
        padding: 30px;
        border-radius: 10px;
        border: 3px solid #fff;
        display: none;
      }

      .blink {
        animation: blink 1s infinite;
      }

      @keyframes blink {
        0%,
        50% {
          opacity: 1;
        }
        51%,
        100% {
          opacity: 0.3;
        }
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="gameCanvas" width="800" height="600"></canvas>
      <div id="ui">âŒ›ï¸ìƒì¡´ì‹œê°„: <span id="timer">0</span>ì´ˆ</div>
      <div id="instructions">
        <h2>ğŸ›¸ UFO í”¼í•˜ê¸° ê²Œì„ ğŸ›¸</h2>
        <p><strong>PC:</strong> â† â†’ ë°©í–¥í‚¤ë¡œ ì´ë™</p>
        <p><strong>ëª¨ë°”ì¼:</strong> í™”ë©´ ì¢Œìš° í„°ì¹˜ë¡œ ì´ë™</p>
        <p class="blink">ìŠ¤í˜ì´ìŠ¤ë°” ë˜ëŠ” í„°ì¹˜ë¡œ ì‹œì‘!</p>
      </div>
      <div id="gameOver">
        <h2>ğŸ’¥ GAME OVER ğŸ’¥</h2>
        <p>ìƒì¡´ì‹œê°„: <span id="finalTime">0</span>ì´ˆ</p>
        <p class="blink">ìŠ¤í˜ì´ìŠ¤ë°” ë˜ëŠ” í„°ì¹˜ë¡œ ì¬ì‹œì‘!</p>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const timerElement = document.getElementById("timer");
      const instructionsElement = document.getElementById("instructions");
      const gameOverElement = document.getElementById("gameOver");
      const finalTimeElement = document.getElementById("finalTime");

      let gameState = "waiting"; // 'waiting', 'playing', 'gameOver'
      let gameStartTime = 0;
      let survivalTime = 0;
      let lastTime = 0;

      // UFO ì„¤ì •
      const ufo = {
        x: canvas.width / 2,
        y: canvas.height - 80,
        width: 40,
        height: 20,
        speed: 5,
      };

      // ìš´ì„ ë°°ì—´
      let meteors = [];

      // UFO ë„íŠ¸ë§µ (ë°˜ì›í˜•)
      const ufoPixelMap = [
        [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
        [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
        [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1], // 2ëŠ” ë¼ì´íŠ¸
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      ];

      // ìš´ì„ ìƒì„±
      function createMeteor() {
        return {
          x: Math.random() * (canvas.width - 20),
          y: -20,
          width: 15,
          height: 15,
          speed: Math.random() * 3 + 2,
        };
      }

      // UFO ê·¸ë¦¬ê¸° (ë„íŠ¸ë§µìœ¼ë¡œ)
      function drawUFO() {
        const pixelSize = 3;
        const startX = ufo.x - (ufoPixelMap[0].length * pixelSize) / 2;
        const startY = ufo.y - (ufoPixelMap.length * pixelSize) / 2;

        for (let row = 0; row < ufoPixelMap.length; row++) {
          for (let col = 0; col < ufoPixelMap[row].length; col++) {
            const pixelValue = ufoPixelMap[row][col];
            if (pixelValue === 1) {
              ctx.fillStyle = "#silver";
              ctx.fillRect(
                startX + col * pixelSize,
                startY + row * pixelSize,
                pixelSize,
                pixelSize
              );
            } else if (pixelValue === 2) {
              ctx.fillStyle = "#00ff00";
              ctx.fillRect(
                startX + col * pixelSize,
                startY + row * pixelSize,
                pixelSize,
                pixelSize
              );
            }
          }
        }
      }

      // ìš´ì„ ê·¸ë¦¬ê¸° (ë„íŠ¸ ìŠ¤íƒ€ì¼)
      function drawMeteor(meteor) {
        const pixelSize = 2;
        ctx.fillStyle = "#ff4444";

        // ìš´ì„ íŒ¨í„´
        const meteorPattern = [
          [0, 1, 1, 0],
          [1, 1, 1, 1],
          [1, 1, 1, 1],
          [0, 1, 1, 0],
        ];

        for (let row = 0; row < meteorPattern.length; row++) {
          for (let col = 0; col < meteorPattern[row].length; col++) {
            if (meteorPattern[row][col] === 1) {
              ctx.fillRect(
                meteor.x + col * pixelSize,
                meteor.y + row * pixelSize,
                pixelSize,
                pixelSize
              );
            }
          }
        }
      }

      // ë³„ ê·¸ë¦¬ê¸° (ë°°ê²½)
      function drawStars() {
        ctx.fillStyle = "#ffffff";
        for (let i = 0; i < 50; i++) {
          const x = (i * 47 + lastTime * 0.01) % canvas.width;
          const y = (i * 37 + lastTime * 0.02) % canvas.height;
          ctx.fillRect(x, y, 1, 1);
        }
      }

      // ì¶©ëŒ ê°ì§€
      function checkCollision(rect1, rect2) {
        return (
          rect1.x < rect2.x + rect2.width &&
          rect1.x + rect1.width > rect2.x &&
          rect1.y < rect2.y + rect2.height &&
          rect1.y + rect1.height > rect2.y
        );
      }

      // ê²Œì„ ì—…ë°ì´íŠ¸
      function update(currentTime) {
        if (gameState !== "playing") return;

        // ìƒì¡´ ì‹œê°„ ì—…ë°ì´íŠ¸
        survivalTime = Math.floor((currentTime - gameStartTime) / 1000);
        timerElement.textContent = survivalTime;

        // ìš´ì„ ìƒì„± (ë‚œì´ë„ ì¦ê°€)
        const meteorSpawnRate = Math.max(0.02, 0.05 - survivalTime * 0.001);
        if (Math.random() < meteorSpawnRate) {
          meteors.push(createMeteor());
        }

        // ìš´ì„ ì—…ë°ì´íŠ¸
        meteors.forEach((meteor, index) => {
          meteor.y += meteor.speed;

          // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°„ ìš´ì„ ì œê±°
          if (meteor.y > canvas.height) {
            meteors.splice(index, 1);
          }

          // UFOì™€ ì¶©ëŒ ì²´í¬
          if (checkCollision(ufo, meteor)) {
            gameState = "gameOver";
            finalTimeElement.textContent = survivalTime;
            gameOverElement.style.display = "block";
          }
        });
      }

      // ê²Œì„ ë Œë”ë§
      function render() {
        // í™”ë©´ í´ë¦¬ì–´
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // ë°°ê²½ ë³„ ê·¸ë¦¬ê¸°
        drawStars();

        if (gameState === "playing") {
          // UFO ê·¸ë¦¬ê¸°
          drawUFO();

          // ìš´ì„ë“¤ ê·¸ë¦¬ê¸°
          meteors.forEach(drawMeteor);
        }
      }

      // ê²Œì„ ë£¨í”„
      function gameLoop(currentTime) {
        update(currentTime);
        render();
        lastTime = currentTime;
        requestAnimationFrame(gameLoop);
      }

      // ê²Œì„ ì‹œì‘
      function startGame() {
        gameState = "playing";
        gameStartTime = performance.now();
        survivalTime = 0;
        meteors = [];
        ufo.x = canvas.width / 2;
        instructionsElement.style.display = "none";
        gameOverElement.style.display = "none";
      }

      // ê²Œì„ ë¦¬ì…‹
      function resetGame() {
        gameState = "waiting";
        instructionsElement.style.display = "block";
        gameOverElement.style.display = "none";
      }

      // í‚¤ë³´ë“œ ì´ë²¤íŠ¸
      document.addEventListener("keydown", (e) => {
        if (e.code === "Space") {
          e.preventDefault();
          if (gameState === "waiting" || gameState === "gameOver") {
            startGame();
          }
        }

        if (gameState === "playing") {
          if (e.code === "ArrowLeft") {
            ufo.x = Math.max(20, ufo.x - ufo.speed);
          } else if (e.code === "ArrowRight") {
            ufo.x = Math.min(canvas.width - 20, ufo.x + ufo.speed);
          }
        }
      });

      // í„°ì¹˜ ì´ë²¤íŠ¸ (ëª¨ë°”ì¼)
      canvas.addEventListener("touchstart", (e) => {
        e.preventDefault();

        if (gameState === "waiting" || gameState === "gameOver") {
          startGame();
          return;
        }

        if (gameState === "playing") {
          const touch = e.touches[0];
          const rect = canvas.getBoundingClientRect();
          const touchX = touch.clientX - rect.left;

          if (touchX < canvas.width / 2) {
            ufo.x = Math.max(20, ufo.x - ufo.speed * 2);
          } else {
            ufo.x = Math.min(canvas.width - 20, ufo.x + ufo.speed * 2);
          }
        }
      });

      // ì—°ì† í‚¤ ì…ë ¥ ì²˜ë¦¬
      const keys = {};
      document.addEventListener("keydown", (e) => {
        keys[e.code] = true;
      });

      document.addEventListener("keyup", (e) => {
        keys[e.code] = false;
      });

      // ì—°ì† ì´ë™ ì²˜ë¦¬
      function handleContinuousInput() {
        if (gameState === "playing") {
          if (keys["ArrowLeft"]) {
            ufo.x = Math.max(20, ufo.x - ufo.speed);
          }
          if (keys["ArrowRight"]) {
            ufo.x = Math.min(canvas.width - 20, ufo.x + ufo.speed);
          }
        }
      }

      // ì—°ì† ì…ë ¥ ì²˜ë¦¬ë¥¼ ìœ„í•œ ë³„ë„ ë£¨í”„
      setInterval(handleContinuousInput, 16);

      // ê²Œì„ ì‹œì‘
      gameLoop(0);
    </script>
  </body>
</html>
