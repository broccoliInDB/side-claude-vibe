<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>UFO 피하기 게임</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: linear-gradient(to bottom, #000428, #004e92);
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-family: "Courier New", monospace;
        color: white;
      }

      #gameContainer {
        position: relative;
        border: 3px solid #fff;
        border-radius: 10px;
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
      }

      #gameCanvas {
        display: block;
        background: linear-gradient(to bottom, #001122, #003366);
      }

      #ui {
        position: absolute;
        top: 10px;
        right: 10px;
        font-size: 20px;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      }

      #instructions {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        font-size: 18px;
        line-height: 1.6;
        background: rgba(0, 0, 0, 0.7);
        padding: 20px;
        border-radius: 10px;
        border: 2px solid #fff;
      }

      #gameOver {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        font-size: 24px;
        background: rgba(255, 0, 0, 0.8);
        padding: 30px;
        border-radius: 10px;
        border: 3px solid #fff;
        display: none;
      }

      .blink {
        animation: blink 1s infinite;
      }

      @keyframes blink {
        0%,
        50% {
          opacity: 1;
        }
        51%,
        100% {
          opacity: 0.3;
        }
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="gameCanvas" width="800" height="600"></canvas>
      <div id="ui">
        생존시간: <span id="timer">0</span>초<br />
        파괴한 운석: <span id="score">0</span>개<br />
        무기레벨: <span id="weaponLevel">1</span>단계
      </div>
      <div id="instructions">
        <h2>🛸 UFO 슈팅 게임 🛸</h2>
        <p><strong>PC:</strong> ← → 방향키로 이동, 스페이스바로 미사일 발사</p>
        <p>
          <strong>모바일:</strong> 화면 좌우 터치로 이동, 화면 상단 터치로
          미사일 발사
        </p>
        <p class="blink">스페이스바 또는 터치로 시작!</p>
      </div>
      <div id="gameOver">
        <h2>💥 GAME OVER 💥</h2>
        <p>생존시간: <span id="finalTime">0</span>초</p>
        <p>파괴한 운석: <span id="finalScore">0</span>개</p>
        <p>최고 무기레벨: <span id="finalWeaponLevel">1</span>단계</p>
        <p class="blink">스페이스바 또는 터치로 재시작!</p>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const timerElement = document.getElementById("timer");
      const scoreElement = document.getElementById("score");
      const weaponLevelElement = document.getElementById("weaponLevel");
      const instructionsElement = document.getElementById("instructions");
      const gameOverElement = document.getElementById("gameOver");
      const finalTimeElement = document.getElementById("finalTime");
      const finalScoreElement = document.getElementById("finalScore");
      const finalWeaponLevelElement =
        document.getElementById("finalWeaponLevel");

      let gameState = "waiting"; // 'waiting', 'playing', 'gameOver'
      let gameStartTime = 0;
      let survivalTime = 0;
      let score = 0;
      let weaponLevel = 1;
      let lastItemSpawnTime = 0;
      let lastTime = 0;

      // UFO 설정
      const ufo = {
        x: canvas.width / 2,
        y: canvas.height - 80,
        width: 40,
        height: 20,
        speed: 5,
      };

      // 운석 배열
      let meteors = [];

      // 미사일 배열
      let missiles = [];

      // 아이템 배열
      let items = [];

      // UFO 도트맵 (반원형)
      const ufoPixelMap = [
        [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
        [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
        [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1], // 2는 라이트
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      ];

      // 미사일 생성 (무기 레벨에 따라 다른 패턴)
      function createMissiles() {
        const missiles = [];
        const baseX = ufo.x;
        const baseY = ufo.y - 10;

        switch (weaponLevel) {
          case 1: // 기본: 1발
            missiles.push({
              x: baseX,
              y: baseY,
              width: 3,
              height: 8,
              speed: 8,
              type: "normal",
            });
            break;
          case 2: // 2단계: 2발 (약간 벌어짐)
            missiles.push({
              x: baseX - 5,
              y: baseY,
              width: 3,
              height: 8,
              speed: 8,
              type: "normal",
            });
            missiles.push({
              x: baseX + 5,
              y: baseY,
              width: 3,
              height: 8,
              speed: 8,
              type: "normal",
            });
            break;
          case 3: // 3단계: 3발 (더 벌어짐)
            missiles.push({
              x: baseX,
              y: baseY,
              width: 3,
              height: 8,
              speed: 8,
              type: "normal",
            });
            missiles.push({
              x: baseX - 8,
              y: baseY,
              width: 3,
              height: 8,
              speed: 8,
              type: "normal",
            });
            missiles.push({
              x: baseX + 8,
              y: baseY,
              width: 3,
              height: 8,
              speed: 8,
              type: "normal",
            });
            break;
          case 4: // 4단계: 레이저 (더 강력)
            missiles.push({
              x: baseX - 10,
              y: baseY,
              width: 5,
              height: 12,
              speed: 10,
              type: "laser",
            });
            missiles.push({
              x: baseX + 10,
              y: baseY,
              width: 5,
              height: 12,
              speed: 10,
              type: "laser",
            });
            break;
          case 5: // 5단계: 플라즈마 (최강)
            missiles.push({
              x: baseX,
              y: baseY,
              width: 8,
              height: 15,
              speed: 12,
              type: "plasma",
            });
            missiles.push({
              x: baseX - 15,
              y: baseY,
              width: 5,
              height: 12,
              speed: 10,
              type: "laser",
            });
            missiles.push({
              x: baseX + 15,
              y: baseY,
              width: 5,
              height: 12,
              speed: 10,
              type: "laser",
            });
            break;
        }

        return missiles;
      }

      // 아이템 생성
      function createItem() {
        return {
          x: Math.random() * (canvas.width - 20) + 10,
          y: -20,
          width: 16,
          height: 16,
          speed: 2,
        };
      }

      // 운석 생성
      function createMeteor() {
        return {
          x: Math.random() * (canvas.width - 20),
          y: -20,
          width: 15,
          height: 15,
          speed: Math.random() * 3 + 2,
        };
      }

      // UFO 그리기 (도트맵으로)
      function drawUFO() {
        const pixelSize = 3;
        const startX = ufo.x - (ufoPixelMap[0].length * pixelSize) / 2;
        const startY = ufo.y - (ufoPixelMap.length * pixelSize) / 2;

        for (let row = 0; row < ufoPixelMap.length; row++) {
          for (let col = 0; col < ufoPixelMap[row].length; col++) {
            const pixelValue = ufoPixelMap[row][col];
            if (pixelValue === 1) {
              ctx.fillStyle = "#silver";
              ctx.fillRect(
                startX + col * pixelSize,
                startY + row * pixelSize,
                pixelSize,
                pixelSize
              );
            } else if (pixelValue === 2) {
              ctx.fillStyle = "#00ff00";
              ctx.fillRect(
                startX + col * pixelSize,
                startY + row * pixelSize,
                pixelSize,
                pixelSize
              );
            }
          }
        }
      }

      // 미사일 그리기 (타입별로 다르게)
      function drawMissile(missile) {
        const pixelSize = 1;

        if (missile.type === "plasma") {
          // 플라즈마: 보라색/핑크 그라데이션 효과
          const gradient = ctx.createRadialGradient(
            missile.x + 4,
            missile.y + 4,
            0,
            missile.x + 4,
            missile.y + 4,
            8
          );
          gradient.addColorStop(0, "#ff00ff");
          gradient.addColorStop(0.5, "#ff66ff");
          gradient.addColorStop(1, "rgba(255, 0, 255, 0)");
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(missile.x + 4, missile.y + 4, 8, 0, Math.PI * 2);
          ctx.fill();

          // 플라즈마 코어
          ctx.fillStyle = "#ffffff";
          ctx.beginPath();
          ctx.arc(missile.x + 4, missile.y + 4, 3, 0, Math.PI * 2);
          ctx.fill();

          // 플라즈마 꼬리 효과
          ctx.fillStyle = "rgba(255, 0, 255, 0.3)";
          ctx.beginPath();
          ctx.moveTo(missile.x + 4, missile.y + 4);
          ctx.lineTo(missile.x + 4, missile.y + 20);
          ctx.lineTo(missile.x + 8, missile.y + 20);
          ctx.closePath();
          ctx.fill();
        } else if (missile.type === "laser") {
          // 레이저: 빨간색 빔 효과
          const gradient = ctx.createLinearGradient(
            missile.x,
            missile.y,
            missile.x,
            missile.y + 12
          );
          gradient.addColorStop(0, "#ff0000");
          gradient.addColorStop(0.5, "#ff6666");
          gradient.addColorStop(1, "rgba(255, 0, 0, 0)");
          ctx.fillStyle = gradient;
          ctx.fillRect(missile.x, missile.y, 5, 12);

          // 레이저 글로우 효과
          ctx.shadowColor = "#ff0000";
          ctx.shadowBlur = 10;
          ctx.fillStyle = "#ff0000";
          ctx.fillRect(missile.x, missile.y, 5, 12);
          ctx.shadowBlur = 0;
        } else {
          // 일반 미사일: 시안색 빔 효과
          const gradient = ctx.createLinearGradient(
            missile.x,
            missile.y,
            missile.x,
            missile.y + 8
          );
          gradient.addColorStop(0, "#00ffff");
          gradient.addColorStop(1, "rgba(0, 255, 255, 0)");
          ctx.fillStyle = gradient;
          ctx.fillRect(missile.x, missile.y, 3, 8);

          // 미사일 글로우 효과
          ctx.shadowColor = "#00ffff";
          ctx.shadowBlur = 5;
          ctx.fillStyle = "#00ffff";
          ctx.fillRect(missile.x, missile.y, 3, 8);
          ctx.shadowBlur = 0;
        }
      }

      // 아이템 그리기
      function drawItem(item) {
        const pixelSize = 2;
        // 파워업 아이템: 초록색 P 모양
        const itemPattern = [
          [1, 1, 1, 1, 0, 0, 0, 0],
          [1, 0, 0, 0, 1, 0, 0, 0],
          [1, 0, 0, 0, 1, 0, 0, 0],
          [1, 1, 1, 1, 0, 0, 0, 0],
          [1, 0, 0, 0, 0, 0, 0, 0],
          [1, 0, 0, 0, 0, 0, 0, 0],
          [1, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
        ];

        ctx.fillStyle = "#00ff00";
        for (let row = 0; row < itemPattern.length; row++) {
          for (let col = 0; col < itemPattern[row].length; col++) {
            if (itemPattern[row][col] === 1) {
              ctx.fillRect(
                item.x + col * pixelSize,
                item.y + row * pixelSize,
                pixelSize,
                pixelSize
              );
            }
          }
        }

        // 반짝이는 효과
        if (Math.floor(lastTime / 200) % 2 === 0) {
          ctx.fillStyle = "#ffffff";
          ctx.fillRect(item.x + 2, item.y + 2, 2, 2);
          ctx.fillRect(item.x + 12, item.y + 6, 2, 2);
        }
      }

      // 운석 그리기 (도트 스타일)
      function drawMeteor(meteor) {
        const pixelSize = 2;

        // 운석 글로우 효과
        ctx.shadowColor = "#ff4444";
        ctx.shadowBlur = 10;

        // 운석 본체
        ctx.fillStyle = "#ff4444";
        ctx.beginPath();
        ctx.arc(meteor.x + 4, meteor.y + 4, 8, 0, Math.PI * 2);
        ctx.fill();

        // 운석 표면 패턴
        ctx.fillStyle = "#ff6666";
        for (let i = 0; i < 3; i++) {
          const angle = ((Math.PI * 2) / 3) * i;
          const x = meteor.x + 4 + Math.cos(angle) * 4;
          const y = meteor.y + 4 + Math.sin(angle) * 4;
          ctx.beginPath();
          ctx.arc(x, y, 2, 0, Math.PI * 2);
          ctx.fill();
        }

        // 운석 꼬리 효과
        const gradient = ctx.createLinearGradient(
          meteor.x + 4,
          meteor.y + 4,
          meteor.x + 4,
          meteor.y + 20
        );
        gradient.addColorStop(0, "rgba(255, 68, 68, 0.8)");
        gradient.addColorStop(1, "rgba(255, 68, 68, 0)");
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(meteor.x + 4, meteor.y + 4);
        ctx.lineTo(meteor.x + 8, meteor.y + 20);
        ctx.lineTo(meteor.x, meteor.y + 20);
        ctx.closePath();
        ctx.fill();

        ctx.shadowBlur = 0;
      }

      // 폭발 효과 그리기
      function drawExplosion(x, y) {
        // 폭발 중심부
        const gradient = ctx.createRadialGradient(
          x + 5,
          y + 5,
          0,
          x + 5,
          y + 5,
          15
        );
        gradient.addColorStop(0, "#ffffff");
        gradient.addColorStop(0.3, "#ffff00");
        gradient.addColorStop(0.7, "#ff6600");
        gradient.addColorStop(1, "rgba(255, 0, 0, 0)");

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x + 5, y + 5, 15, 0, Math.PI * 2);
        ctx.fill();

        // 폭발 파편 효과
        for (let i = 0; i < 8; i++) {
          const angle = ((Math.PI * 2) / 8) * i;
          const length = 10 + Math.random() * 10;
          const endX = x + 5 + Math.cos(angle) * length;
          const endY = y + 5 + Math.sin(angle) * length;

          const fragmentGradient = ctx.createLinearGradient(
            x + 5,
            y + 5,
            endX,
            endY
          );
          fragmentGradient.addColorStop(0, "#ffff00");
          fragmentGradient.addColorStop(1, "rgba(255, 0, 0, 0)");

          ctx.strokeStyle = fragmentGradient;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x + 5, y + 5);
          ctx.lineTo(endX, endY);
          ctx.stroke();
        }

        // 폭발 글로우 효과
        ctx.shadowColor = "#ffff00";
        ctx.shadowBlur = 20;
        ctx.fillStyle = "rgba(255, 255, 0, 0.3)";
        ctx.beginPath();
        ctx.arc(x + 5, y + 5, 20, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // 별 그리기 (배경)
      function drawStars() {
        ctx.fillStyle = "#ffffff";
        for (let i = 0; i < 50; i++) {
          const x = (i * 47 + lastTime * 0.01) % canvas.width;
          const y = (i * 37 + lastTime * 0.02) % canvas.height;
          ctx.fillRect(x, y, 1, 1);
        }
      }

      // 충돌 감지
      function checkCollision(rect1, rect2) {
        return (
          rect1.x < rect2.x + rect2.width &&
          rect1.x + rect1.width > rect2.x &&
          rect1.y < rect2.y + rect2.height &&
          rect1.y + rect1.height > rect2.y
        );
      }

      // 게임 업데이트
      function update(currentTime) {
        if (gameState !== "playing") return;

        // 생존 시간 업데이트
        survivalTime = Math.floor((currentTime - gameStartTime) / 1000);
        timerElement.textContent = survivalTime;
        scoreElement.textContent = score;
        weaponLevelElement.textContent = weaponLevel;

        // 아이템 생성 (비정규적 시간, 5-15초 간격)
        if (currentTime - lastItemSpawnTime > 5000 + Math.random() * 10000) {
          if (weaponLevel < 5) {
            // 최대 레벨이 아닐 때만 생성
            items.push(createItem());
            lastItemSpawnTime = currentTime;
          }
        }

        // 운석 생성 (난이도 증가)
        const meteorSpawnRate = Math.max(0.02, 0.05 - survivalTime * 0.001);
        if (Math.random() < meteorSpawnRate) {
          meteors.push(createMeteor());
        }

        // 아이템 업데이트
        items.forEach((item, itemIndex) => {
          item.y += item.speed;

          // 화면 밖으로 나간 아이템 제거
          if (item.y > canvas.height) {
            items.splice(itemIndex, 1);
            return;
          }

          // UFO와 아이템 충돌 체크
          if (checkCollision(ufo, item)) {
            items.splice(itemIndex, 1);
            if (weaponLevel < 5) {
              weaponLevel++;
              // 레벨업 효과음 대신 시각적 효과
              setTimeout(() => {
                ctx.fillStyle = "#00ff00";
                ctx.font = "20px Courier New";
                ctx.fillText(
                  "POWER UP!",
                  canvas.width / 2 - 50,
                  canvas.height / 2
                );
              }, 0);
            }
          }
        });

        // 미사일 업데이트
        missiles.forEach((missile, missileIndex) => {
          missile.y -= missile.speed;

          // 화면 밖으로 나간 미사일 제거
          if (missile.y < -10) {
            missiles.splice(missileIndex, 1);
            return;
          }

          // 미사일과 운석 충돌 체크
          meteors.forEach((meteor, meteorIndex) => {
            if (checkCollision(missile, meteor)) {
              // 폭발 효과
              setTimeout(() => drawExplosion(meteor.x, meteor.y), 0);

              // 플라즈마는 관통, 다른 미사일은 소멸
              if (missile.type !== "plasma") {
                missiles.splice(missileIndex, 1);
              }
              meteors.splice(meteorIndex, 1);
              score++;
            }
          });
        });

        // 운석 업데이트
        meteors.forEach((meteor, index) => {
          meteor.y += meteor.speed;

          // 화면 밖으로 나간 운석 제거
          if (meteor.y > canvas.height) {
            meteors.splice(index, 1);
          }

          // UFO와 충돌 체크
          if (checkCollision(ufo, meteor)) {
            gameState = "gameOver";
            finalTimeElement.textContent = survivalTime;
            finalScoreElement.textContent = score;
            finalWeaponLevelElement.textContent = weaponLevel;
            gameOverElement.style.display = "block";
          }
        });
      }

      // 게임 렌더링
      function render() {
        // 화면 클리어
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 배경 별 그리기
        drawStars();

        if (gameState === "playing") {
          // UFO 그리기
          drawUFO();

          // 미사일들 그리기
          missiles.forEach(drawMissile);

          // 아이템들 그리기
          items.forEach(drawItem);

          // 운석들 그리기
          meteors.forEach(drawMeteor);
        }
      }

      // 게임 루프
      function gameLoop(currentTime) {
        update(currentTime);
        render();
        lastTime = currentTime;
        requestAnimationFrame(gameLoop);
      }

      // 게임 시작
      function startGame() {
        gameState = "playing";
        gameStartTime = performance.now();
        lastItemSpawnTime = performance.now();
        survivalTime = 0;
        score = 0;
        weaponLevel = 1;
        meteors = [];
        missiles = [];
        items = [];
        ufo.x = canvas.width / 2;
        instructionsElement.style.display = "none";
        gameOverElement.style.display = "none";
      }

      // 게임 리셋
      function resetGame() {
        gameState = "waiting";
        instructionsElement.style.display = "block";
        gameOverElement.style.display = "none";
      }

      // 키보드 이벤트
      document.addEventListener("keydown", (e) => {
        if (e.code === "Space") {
          e.preventDefault();
          if (gameState === "waiting" || gameState === "gameOver") {
            startGame();
          } else if (gameState === "playing") {
            // 미사일 발사 (무기 레벨에 따라 여러 발)
            const newMissiles = createMissiles();
            missiles.push(...newMissiles);
          }
        }

        if (gameState === "playing") {
          if (e.code === "ArrowLeft") {
            ufo.x = Math.max(20, ufo.x - ufo.speed);
          } else if (e.code === "ArrowRight") {
            ufo.x = Math.min(canvas.width - 20, ufo.x + ufo.speed);
          }
        }
      });

      // 터치 이벤트 (모바일)
      canvas.addEventListener("touchstart", (e) => {
        e.preventDefault();

        if (gameState === "waiting" || gameState === "gameOver") {
          startGame();
          return;
        }

        if (gameState === "playing") {
          const touch = e.touches[0];
          const rect = canvas.getBoundingClientRect();
          const touchX = touch.clientX - rect.left;
          const touchY = touch.clientY - rect.top;

          // 화면 상단 1/3 터치시 미사일 발사
          if (touchY < canvas.height / 3) {
            const newMissiles = createMissiles();
            missiles.push(...newMissiles);
          } else {
            // 하단 터치시 이동
            if (touchX < canvas.width / 2) {
              ufo.x = Math.max(20, ufo.x - ufo.speed * 2);
            } else {
              ufo.x = Math.min(canvas.width - 20, ufo.x + ufo.speed * 2);
            }
          }
        }
      });

      // 연속 키 입력 처리
      const keys = {};
      document.addEventListener("keydown", (e) => {
        keys[e.code] = true;
      });

      document.addEventListener("keyup", (e) => {
        keys[e.code] = false;
      });

      // 연속 이동 처리
      function handleContinuousInput() {
        if (gameState === "playing") {
          if (keys["ArrowLeft"]) {
            ufo.x = Math.max(20, ufo.x - ufo.speed);
          }
          if (keys["ArrowRight"]) {
            ufo.x = Math.min(canvas.width - 20, ufo.x + ufo.speed);
          }
        }
      }

      // 연속 입력 처리를 위한 별도 루프
      setInterval(handleContinuousInput, 16);

      // 게임 시작
      gameLoop(0);
    </script>
  </body>
</html>
